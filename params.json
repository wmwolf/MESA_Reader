{"name":"Mesa Reader","tagline":"Tools for easily reading and accessing data created by MESA, particularly for use in plotting.","body":"#MesaReader: The easy way to access your MESA data\r\n___\r\n\r\n## What Is MesaReader?\r\n\r\nThis file gives you access to a ruby module, MesaReader, containing three\r\nclasses: MesaData, MesaProfileIndex, and MesaLogDir. The primary use is\r\nintended for plotting in\r\n[Tioga](http://www.kitp.ucsb.edu/members/PM/paxton/tioga.html), but as the \r\ntools become more sophisticated, analysis can be done on the fly with irb or\r\nstandalone scripts.\r\n\r\n## Installation ##\r\n\r\n### Prerequisites ###\r\n\r\nObivously you need an installation of Ruby. I haven't found any conflicts with Ruby 1.8.7, 1.9.3, or 2.0+, and I'm told it now works with 1.8.6. If you are doing a manual installation, you will also need to have tiogga, a plotting\r\npackage, installed since MesaReader gathers data into Dvectors, which are a\r\npart of Tioga.\r\n\r\n### Quick Installation ###\r\n\r\nAs of this writing, MesaReader is now packaged as a gem. If you have RubyGems\r\nworking (and you probably do), you should be able to install it via\r\n\r\n    gem install mesa_reader\r\n\r\nYou may need to have superuser privileges, so just prepend `sudo` to the\r\nprevious command if rubygems barks at you about privileges. Tioga is a\r\nprerequisite since MesaReader loads data into Dvectors, but Tioga installation\r\nshould occur automatically.\r\n\r\n### Manual Installation ###\r\n\r\nIf you can't use a RubyGems installation, you can manually place the \r\n`mesa_reader.rb` file in useful location for installation. Copying it to\r\nyour work directory may be sufficient if you just plan to use this for plotting\r\npurposes since it will copy over with the rest of the directory whenever you\r\nmake a new work directory.\r\n\r\nAnother possible installation idea that I've been using is to clone the git\r\nrepository somewhere sensible on my machine and then create a pointer file in \r\nmy Ruby path (see below). For instance, I have a file in `/usr/lib/ruby/` \r\ncalled `mesa_reader.rb` that has one line:\r\n\r\n\trequire '/Users/wmwolf/Documents/MESA_Reader/mesa_reader/lib/mesa_reader.rb'\r\n\r\nThat way, the source file is easily accessible in my git repo while also being\r\nreadable from Ruby's path. That is, when you tell ruby to require MesaReader,\r\nit will find the file in its path, which will then load the file from your\r\nlocal repo.\r\n\r\nTo clone the git repo on  your machine (assuming you\r\nhave git installed), `cd` to the directory where you want it installed and clone\r\nit. You'll want to change the path to where you want to install the file, but\r\nthe commands are\r\n\r\n\tcd ~/Documents\r\n\tgit clone https://github.com/wmwolf/MESA_Reader.git MesaReader\r\n\r\nwhich will install the contents of the repo (currently a RubyGems-style directory for MesaReader and this README) into a directory called MesaReader in your Documents\r\ndirectory. Then any time you want to update to the latest release, you can do\r\n\r\n\tcd ~/Documents/MesaReader\r\n\tgit pull\r\n\r\nOr, hopefully, you can make your own additions and push updates for me to add!\r\n\r\n### Global Installation ###\r\n\r\nFor a more permanent solution, put mesa_reader.rb in your ruby path. For me\r\n(on a mac), placing it in `/usr/lib/ruby/` did the trick. To see where you\r\nshould install the file for global use enter the following line into your\r\nterminal\r\n\r\n\truby -e 'puts $:'\r\n\r\nThis should give you a list of directories that would work for installation. To\r\nupdate to a newer version of these tools, just move the new file to the same\r\nplace.\r\n\r\n## Making the Module Available\r\nIn your program (or irb), just start with\r\n\r\n\trequire 'mesa_reader'\r\n\r\nIf the file is in the same directory as your current working one, it will be\r\nread from there. Otherwise, ruby will search through its available paths for a\r\nfile called `mesa_reader.rb` and load the first one it finds. Note that in Ruby\r\n2.0+, the working directory is no longer on the search. You must either use\r\n`require_relative` or explicitly indicate that you want to search the current\r\ndirectory with `require './mesa_reader`. This will also work in earlier versions of ruby, so if you are requiring a local copy, you should get in this\r\nhabit.\r\n\r\nIf you want direct access to the classes, you will also need to put in the line\r\n\r\n    include MesaReader\r\n\r\nThis takes all of the contents of the module `MesaReader` and drops them into \r\nyour current namespace. If you don't do this, you'll just have to add \r\n`MesaReader::` in front of any class name, like `MesaReader::MesaData` or \r\n`MesaReader::MesaLogDir`. For subsequent examples, I'll assume you have\r\nincluded the entire module (i.e., no more typing out `MesaReader::`).\r\n\r\n## Creating Instances\r\nTo create a simple `MesaData` instance, use the class `#initialize` method:\r\n\r\n\ts = MesaData.new(FILEPATH)\r\n\r\nwhere `FILEPATH` is a string that is the path (relative or fully-qualified) to\r\nthe file you wish to read in. For instance, if you are in the work directory\r\nand you want to read in the history file, you would use `'LOGS/history.data'`\r\nin place of `FILEPATH`. You can load history or profile files since the basic\r\n`MesaData` object doesn't know the difference (though when loading history\r\nfiles, it does know to throw out backups, retries, and restarts, ensuring that\r\nthe model numbers are monotonically increasing).\r\n\r\nTo create a `MesaProfileIndex` instance, we'll use that class' `#initialize`\r\nmethod as well.\r\n\r\n\tm = MesaProfileIndex.new(FILEPATH)\r\n\r\nwhere now `FILEPATH` is a string containing the path to your profiles index\r\nfile, like `'LOGS/profiles.index'`.\r\n\r\nFinally, to make a `MesaLogDir` instance, we use that class' `#initialize`\r\nmethod again. Unlike the first two examples, though, this class can take many\r\nmore initialization parameters. To use just two of them, here's an example:\r\n\r\n\tl = MesaLogDir.new('log_path' => '~/mesa/star/work/LOGS', 'history_file' => 'history.data')\r\n\r\nYou can also set `'profile_prefix'`, `'profile_suffix'`, and `'index_file'`,\r\nwhich denote the part of the name of profile before the number, the suffix of a\r\nprofile file, and the full name of the index file. The defaults are\r\n\r\n\t'log_path'       => 'LOGS'\r\n\t'profile_prefix' => 'profile'\r\n\t'profile_suffix' => 'data'\r\n\t'history_file'   => 'history.data'\r\n\t'index_file'     => 'profiles.index\r\n\r\nNormally these shouldn't need to be altered, and so long as you don't have custom-named log directories, `l = MesaLogDir.new`, with no options, should suffice.\r\n\r\n## MesaData Methods\r\n\r\nThere are many publicly accessible instance methods for `MesaData` objects.\r\nTheir usage is detailed below. For convenience, we'll assume that `s` is an\r\ninstance of the `MesaData` class. That is, assume we have already done\r\n\r\n\ts = MesaData.new('LOGS/history.data')\r\n\r\n### `#bulk_data`\r\nReturns an array of Dvectors containing the columns from the source file. This\r\nisn't very useful and is really only a diagnostic tool.\r\n\r\n### `#bulk_names`\r\nReturns an array of strings that are the names of each of the data columns.\r\nThese are the strings at the top of each data column from the source file.\r\nTogether with `#bulk_data` forms a hash that is accessed using the `#data`\r\ncommand to convert data column names into Dvectors.\r\n\r\n### `#data(key)`\r\nAccepts a string and returns the corresponding Dvector from `#bulk_data`. This\r\nis the main usage of the class.\r\n\r\n\ts.data('model_number') => [1.0, 2.0, 3.0, 4.0, ...]\r\n\r\nReturns `nil` and prints a warning if no such key exists in `s.bulk_names`.\r\n\r\n### `#data_at_model_number(key, model_number)`\r\nAccepts a string and a model number (float or integer) and returns the value of\r\n`s.data(key)` at the index corresponding to the given model number. If no such \r\ndata category exists, returns `nil` and prints a warning. An exception will be\r\nthrown if `model_number` is not a data category or if the given model number is\r\noutside the range of `s.data('model_number')`.\r\n\r\n### `#data?(key)`\r\nAccepts a string and returns `true` if the entry is found in `s.bulk_names` and\r\n`false` otherwise.\r\n\r\n### `#file_name`\r\nReturns a string containing the name of the file that was read into the\r\ninstance.\r\n\r\n### `#header(key)`\r\nAccepts a string and returns the corresponding value from `#header_data`. The\r\n`key` value must be in `s.header_names` or else it will return `nil` (and a\r\nwarning will be printed). Works in much the same way as `#data` but with the\r\nheader data rather than the bulk data.\r\n\r\n### `#header?(key)`\r\nAccepts a string and returns `true` if the string is in `s.header_names`.\r\n\r\n### `#header_data`\r\nReturns an array of all the data in the header row of the source file.\r\n\r\n### `#header_names`\r\nReturns an array of strings containing all the names of the header data entries.\r\n\r\n### `#where(keys)`\r\nAccepts an arbitrary (at least one) number of strings as arguments, each of\r\nwhich must be a member of `s.bulk_names`. Then yields each member of\r\n`s.data(key1)`, `s.data(key2)`, etc. into a [required] block and performs a\r\nuser-specified test on those data. Returns an array of integers containing the\r\nindices of the set members that passed the test. For example\r\n\r\n\ts.where('star_age', 'log_L') { |age, lum| age > 1e6 and lum > 2 }\r\n\r\nreturns an array containing the indices , `i` such that \r\n`s.data('star_age')[i] > 1e6` and `s.data('log_L')[i] > 2`. A common usage\r\nwould then be to feed these indices back in to get a subset of an array from\r\n`s.data('star_age')`. For instance, one could get all the values of the\r\nluminosity for times later than a million years via\r\n\r\n\ts.data('luminosity').values_at(*s.where('star_age) { |age| age > 1e6 })\r\n  \r\n### Magic Methods\r\nDepending on the type of file read in to the object (specifically what ends up\r\nin `s.bulk_names`), you can also access the bulk data through some shorthand\r\nwithout using the `#data` method. So long as the data name isn't already a \r\ndefined method on the `MesaData` class, you can simply use its name as a method\r\nwhich just returns `data(\"#{name}\")`. That is, if you load in a history file, \r\n\r\n\ts.data('model_number')\r\n  \r\nand\r\n\r\n\ts.model_number\r\n  \r\nshould return the same thing. This is essentially just syntatic sugar, but it\r\nmakes for more readable code. The `#data` way of doing things is always invoked\r\nat some point, so it is the \"preferred\" method of accessing data, but magic\r\nmethods should, for nearly all cases, perform just as well unless you have\r\nunfortunately named data categories (starting with numbers, or they are\r\ntragically named the same as an already existing method, like, `nil?`).\r\n\r\nIf the method name used is not in `s.bulk_names` but is in `s.header_names`,\r\nthen it returns the appropriate header data instead. If the name is in both \r\nthe header and data names, the data entry wins (this sometimes happens with \r\nthings like `version_number` and the like). If you use an invalid method (i.e. \r\none that is not explicitly defined in the class or its superclass, the basic \r\nRuby object `Object`, or a method implicitly defined from the data and header\r\ncategories via magic methods) a `NameError` will be thrown, just like it is for\r\nany other case of a bad method call.\r\n \t\r\n## MesaProfileIndex Methods\r\n\r\nThere are five publicly accessible methods for the `MesaProfileIndex` class,\r\nthough likely the only useful methods are `#have_profile_with_model_number?`\r\nand `#profile_with_model_number`, which allow you to obtain a model number from\r\na model number. In practice, this class isn't very useful on its own, but is\r\nused extensively in the `MesaLogDir` class.\r\n\t\r\n### `#have_profile_with_model_number?(model_number)`\r\nAccepts an integer, a model number, and returns `true` if there is a profile\r\navailable with that model number. Otherwise returns `false`.\r\n\r\n### `#have_profile_with_profile_number?(profile_number)`\r\nAccepts an integer, a profile number, and returns `true` if there is a profile\r\nwith that profile number. Otherwise returns `false`.\r\n\r\n### `#model_numbers`\r\nReturns a Dvector containing all the model numbers that have profiles available.\r\n\r\n### `#profile_numbers`\r\nReturns a Dvector containing all the profile numbers available.\r\n\r\n### `#profile_with_model_number(model_number)`\r\nAccepts an integer model number and returns the profile number that corresponds\r\nto it. Returns `nil` if there is no such profile.\r\n\r\n## `MesaLogDir Methods`\r\nWe'll suppose we've already made an instance for the purpose of examples via\r\n\r\n\tl = MesaLogDir.new\r\n\r\nIn addition to the methods defined below, all the methods of `MesaProfileIndex`\r\nare available and are simply called on the internal `MesaProfileIndex` created\r\nwithin the `MesaLogDir` structure.\r\n\t\r\n### `#contents`\r\nReturns an array of strings containing names of all the files in the directory\r\nreturned by `l.log_path`.\r\n\r\n### `#history_data`\r\nReturns a `MesaData` instance made from `l.history_file` in `l.log_path`. This\r\nobject is created at initialization and is thus \"free\". There's no need to\r\ncatch this in a variable to spare the MesaData initialization process each time\r\nit is called.\r\n\r\n### `#history` ###\r\nAlias for `history`.\r\n\r\n### `#history_file`\r\nReturns the name of the history data file in `l.log_path`.\r\n\r\n### `#index_file`\r\nReturns the name of the profile index file in `l.log_path`.\r\n\r\n### `#log_path`\r\nReturns a string containing the given path to the logs directory.\r\n\r\n### `#profiles`\r\nReturns a `MesaProfileIndex` instance built from `l.index_file`\r\n\r\n### `#profile_data(params)`\r\nAccepts two possible integer arguments, `'model_number'` or `'profile_number'`\r\nwhich specify a profile to be loaded. If neither are given, the profile with\r\nthe largest model number (i.e., the last saved profile) is selected. Returns a\r\n`MesaData` object built from this profile. If the model number provided has no\r\nprofile (i.e. `l.profiles.profile_with_model_number(params['model_number']) =>\r\nnil`), then the default model number is selected. If a profile number is used,\r\nit will attempt to use it no matter what, triggering an error if the given\r\nprofile number is invalid. For example\r\n\r\n\tp = l.profile_data('model_number' => 300)\r\n\r\nwould set `p` to be a `MesaData` object built from the profile data associated\r\nwith model number 300. If no such model number existed, though, it would pull\r\ndata from the profile with the largest model number. If we instead used\r\n\r\n\tp = l.profile_data('model_number' => 300, 'profile_number' => 15)\r\n\r\nthen `p` would be set to a `MesaData` object with profile number 15. The\r\n`'model_number'` entry is entirely ignored. If there was no profile with\r\nprofile number 15, an exception will be raised. Essentially there is never a\r\ntime when it is helpful to specify both a model number and a profile number,\r\nand again, if neither are specified, the profile with the largest model number\r\nis used.\r\n\r\nEach of these objects are made as this is called. That is, they aren't \"sitting\r\naround\" like the history MesaData object. As such, these should be captured in\r\na variable so that they aren't re-constructed each time they are needed.\r\n\r\n### `#profile_prefix`\r\nReturns the string containing the profile prefix as defined in the\r\n`MesaProfileIndex` class.\r\n\r\n### `#profile_suffix`\r\nReturns the string containing the profile suffix as defined in the\r\n`MesaProfileIndex` class.\r\n\r\n### `#select_models(keys)`\r\nNearly identical to `#where` in the `MesaData` class, but ensures that the\r\nreturned model numbers have corresponding profile files. Accepts an arbitrary\r\nnumber (at least one) of strings that must be in `l.history_data.bulk_names`\r\nand yields successive values of `l.history_data.data(key)` for each key to a\r\nuser-specified block that should return a boolean. Only those model numbers\r\nthat have available profiles are tested, so the returned Dvector of model\r\nnumbers (not indices, like in `#where`) have available profiles *and* pass the\r\ntest provided by the user. As an example\r\n\r\n\tmodels_to_plot = l.select_models('log_center_T', 'log_center_Rho') { |log_tc, log_rhoc| log_tc > 8 and log_rhoc > 3 }\r\n\r\nwill return a Dvector of model numbers that have profiles available for reading\r\nin *and* have central temperatures exceeding 1e8 *and* have central densities\r\nexceeding 1e3.\r\n\r\n## Some Additional Thoughts\r\nThe uses for these classes are pretty generic. As stated earlier, they were\r\ndeveloped primarily to ease plotting MESA data in Tioga, but they are also\r\nquite useful for manipulating the data in their own rite for numerical\r\npurposes. The only reason you might not want to do that is that Ruby isn't the\r\nfastest language available, but then again, if you are dealing with such large\r\nMESA data sets that the computational timescales are getting too long for your\r\ncomfort, you are in a pretty remarkable situation. As a practical note, if you\r\nuse this in irb and you make an instance of `MesaData`, I'd recommend\r\nfollowing that up with a semi-colon and `nil` unless you want to see a ton of\r\nnumbers fly up your screen. For instance, do this\r\n\r\n\tl = MesaLogDir.new; nil\r\n\r\nThe `nil` keeps irb from outputting all the data held in `l`. Or consider using\r\nthe wonderful irb replacement [Pry](http://pryrepl.org) which can make\r\nexploring your data outside of plots a much more pleasant experience (for\r\ninstance a simple semi-colon will suppress outputting the return value). If you\r\nhave any problems with or suggestions for further development of these classes,\r\nplease contact me or better yet, make some commits and push the changes for\r\ndeployment!\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}